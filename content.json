{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Daisy","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"浏览器关键渲染路径与阻塞渲染以及渲染优化","slug":"浏览器关键渲染路径与阻塞渲染以及渲染优化","date":"2018-11-01T14:12:13.000Z","updated":"2019-07-14T14:27:10.209Z","comments":true,"path":"2018/11/01/浏览器关键渲染路径与阻塞渲染以及渲染优化/","link":"","permalink":"http://yoursite.com/2018/11/01/浏览器关键渲染路径与阻塞渲染以及渲染优化/","excerpt":"","text":"1. 前言 在浏览器拿到HTML, CSS JS 等外部资源到渲染出页面的过程，有一个重要的概念，例如为了保障首屏内容的最快速显示，通常会提到一个渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。了解原理可以让我们更好的优化关键渲染路径，从而获得更好的用户体验。 2. 阻塞资源现代浏览器总是并行加载资源，例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。 同时由于： 1. CSS 被视为渲染阻塞资源(包括JS)，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕，才会进行下一阶段。 2. JavaScript 被认为是解释器阻塞资源，HTML解析会被JS阻塞，它不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性 存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外： 1.当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。 2.JavaScript 可以查询和修改 DOM 与 CSSOM。 3.CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则： 1.CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。 2.JavaScript 应尽量少影响 DOM 的构建。 3. CSS加载 1. p { color: red; } 这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。 2.渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。 最容易想到的当然是精简 CSS 并尽快提供它。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。 第一个资源会加载并阻塞。 第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。 第三个资源提供了媒体查询，会在符合条件时阻塞渲染。 关于CSS加载的阻塞情况： 1.css加载不会阻塞DOM树的解析 2.css加载会阻塞DOM树的渲染 3.css加载会阻塞后面js语句的执行没有js的理想情况下，html与css会并行解析，分别生成DOM与CSSOM，然后合并成Render Tree，进入Rendering Pipeline；但如果有js，css加载会阻塞后面js语句的执行，而（同步）js脚本执行会阻塞其后的DOM解析（所以通常会把css放在头部，js放在body尾） 4. JS加载 1.如果没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的HTML元素之前，也就是说不等待后续载入的HTML元素，读到就加载并执行 2.解析过程中无论遇到的JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒JavaScript解析器，就会进行暂停 (blocked )浏览器解析HTML，并等到 CSSOM 构建完毕，才去执行js脚本。因为脚本中可能会操作DOM元素，而如果在加载执行脚本的时候DOM元素并没有被解析，脚本就会因为DOM元素没有生成取不到响应元素，所以实际工程中，我们常常将资源放到文档底部。 改变脚本加载次序defer与asyncdefer 与 async 可以改变之前的那些阻塞情形，这两个属性都会使 script 异步加载，然而执行的时机是不一样的。注意 async 与 defer 属性对于 inline-script 都是无效的1.deferdefer 属性表示延迟执行引入 JavaScript，即 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，再触发DOMContentLoaded(初始的 HTML 文档被完全加载和解析完成之后触发，无需等待样式表图像和子框架的完成加载) 事件。 defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 2.asyncasync 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发(HTML解析完成事件)之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。从上一段也能推出，多个 async-script 的执行顺序是不确定的，谁先加载完谁执行。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true。 5. 优化渲染性能 1.动画实现使用requestAnimationFrame 2.长耗时的JS代码放到Web Worker 中执行 JS代码运行在浏览器的主线程上，与此同时，浏览器的主线程还负责样式计算、布局、绘制的工作，如果JavaScript代码运行时间过长，就会阻塞其他渲染工作，很可能会导致丢帧。 每帧的渲染应该在16ms内完成，但在动画过程中，由于已经被占用了不少时间，所以JavaScript代码运行耗时应该控制在3-4毫秒。 如果真的有特别耗时且不操作DOM元素的纯计算工作，可以考虑放到Web Workers中执行。 3.拆分操作DOM元素的任务，分别在多个frame完成 由于Web Workers不能操作DOM元素的限制，所以只能做一些纯计算的工作，对于很多需要操作DOM元素的逻辑，可以考虑分步处理，把任务分为若干个小任务，每个任务都放到requestAnimationFrame中回调执行 4.降低样式计算的范围和复杂度 添加或移除一个DOM元素、修改元素属性和样式类、应用动画效果等操作，都会引起DOM结构的改变，从而导致浏览器要repaint或者reflow。那么这里可以采取一些措施。 1. 降低样式选择器的复杂度 尽量保持class的简短，或者使用Web Components框架。 .box:nth-last-child(-n+1) .title {} // 改善后 .final-box-title {} 2. 减少需要执行样式计算的元素个数 由于浏览器的优化，现代浏览器的样式计算直接对目标元素执行，而不是对整个页面执行，所以我们应该尽可能减少需要执行样式计算的元素的个数。 5.避免大规模、复杂的布局 布局就是计算DOM元素的大小和位置的过程，如果你的页面中包含很多元素，那么计算这些元素的位置将耗费很长时间。布局的主要消耗在于：1. 需要布局的DOM元素的数量；2. 布局过程的复杂程度 1. 尽可能避免触发布局 当你修改了元素的属性之后，浏览器将会检查为了使这个修改生效是否需要重新计算布局以及更新渲染树，对于DOM元素的几何属性修改，比如width/height/left/top等，都需要重新计算布局。 对于不能避免的布局，可以使用Chrome DevTools工具的Timeline查看布局的耗时，以及受影响的DOM元素数量。 2. 使用flexbox替代老的布局模型 老的布局模型以相对/绝对/浮动的方式将元素定位到屏幕上，而Floxbox布局模型用流式布局的方式将元素定位到屏幕上。通过一个小实验可以看出 3. 避免强制同步布局事件的发生 根据渲染流程，JS脚本是在layout之前执行，但是我们可以强制浏览器在执行JS脚本之前先执行布局过程，这就是所谓的强制同步布局。 12345678910111213141516requestAnimationFrame(logBoxHeight);// 先写后读，触发强制布局function logBoxHeight() &#123; // 更新box样式 box.classList.add('super-big'); // 为了返回box的offersetHeight值 // 浏览器必须先应用属性修改，接着执行布局过程 console.log(box.offsetHeight);&#125;// 先读后写，避免强制布局function logBoxHeight() &#123; // 获取box.offsetHeight console.log(box.offsetHeight); // 更新box样式 box.classList.add('super-big');&#125; 在JS脚本运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧的值。因此，如果你在当前帧获取属性之前又对元素节点有改动，那就会导致浏览器必须先应用属性修改，结果执行布局过程，最后再执行JS逻辑。 4.避免连续的强制同步布局发生 如果连续快速的多次触发强制同步布局，那么结果更糟糕。 比如下面的例子，获取box的属性，设置到paragraphs上，由于每次设置paragraphs都会触发样式计算和布局过程，而下一次获取box的属性必须等到上一步设置结束之后才能触发。 1234567891011121314function resizeWidth() &#123; // 会让浏览器陷入'读写读写'循环 for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px'; &#125;&#125;// 改善后方案var width = box.offsetWidth;function resizeWidth() &#123; for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px'; &#125;&#125; 5.简化绘制的复杂度、减少绘制区域 Paint就是填充像素的过程，通常这个过程是整个渲染流程中耗时最长的一环，因此也是最需要避免发生的一环。 如果Layout被触发，那么接下来元素的Paint一定会被触发。当然纯粹改变元素的非几何属性，也可能会触发Paint，比如背景、文字颜色、阴影效果等。 1. 提升移动或渐变元素的绘制层 绘制并非总是在内存中的单层画面里完成的，实际上，浏览器在必要时会将一帧画面绘制成多层画面，然后将这若干层画面合并成一张图片显示到屏幕上。 这种绘制方式的好处是，使用transform来实现移动效果的元素将会被正常绘制，同时不会触发其他元素的绘制。 2. 减少绘制区域，简化绘制的复杂度 浏览器会把相邻区域的渲染任务合并在一起进行，所以需要对动画效果进行精密设计，以保证各自的绘制区域不会有太多重叠。 另外可以实现同样效果的不同方式，应该采用性能更好的那种。 3. 通过Chrome DevTools来分析绘制复杂度和时间消耗，尽可能降低这些指标 打开DevTools，在弹出的面板中，选中More Tools &gt; Rendering选项卡下的Paint flashing，这样每当页面发生绘制的时候，屏幕就会闪现绿色的方框。通过该工具可以检查Paint发生的区域和时机是不是可以被优化。 通过Chrome DevTools中的Timeline &gt; Paint选项可以查看更细节的Paint信息 6.优先使用渲染层合并属性、控制层数量 1. 使用transform/opacity实现动画效果 使用transform/opacity实现动画效果，会跳过渲染流程的布局和绘制环节，只做渲染层的合并。 Type Func Position transform: translate(-px,-px) Scale transform: scale(-) Rotation transform: rotate(-deg) Skew transform: skew(X/Y)(-deg) Matrix transform: matrix(3d)(..) Opacity opacity: 0-1 使用transform/opacity的元素必须独占一个渲染层，所以必须提升该元素到单独的渲染层。 2. 提升动画效果中的元素 应用动画效果的元素应该被提升到其自有的渲染层，但不要滥用。 在页面中创建一个新的渲染层最好的方式就是使用CSS属性will-change，对于目前还不支持will-change属性、但支持创建渲染层的浏览器，可以通过3D transform属性来强制浏览器创建一个新的渲染层。需要注意的是，不要创建过多的渲染层，这意味着新的内存分配和更复杂的层管理。 注意，IE11，Edge17都不支持这一属性。 .moving-element { will-change: transform; transform: translateZ(0); } 3. 管理渲染层、避免过多数量的层 尽管提升渲染层看起来很诱人，但不能滥用，因为更多的渲染层意味着更多的额外的内存和管理资源，所以当且仅当需要的时候才为元素创建渲染层。 * { will-change: transform; transform: translateZ(0); } 4. 使用Chrome DevTools来了解页面的渲染层情况 开启Timeline &gt; Paint选项，然后录制一段时间的操作，选择单独的帧，看到每个帧的渲染细节，在ESC弹出框有个Layers选项，可以看到渲染层的细节，有多少渲染层，为何被创建？ 8. 对用户输入事件的处理函数去抖动（移动设备） 用户输入事件处理函数会在运行时阻塞帧的渲染，并且会导致额外的布局发生。 1. 避免使用运行时间过长的输入事件处理函数 理想情况下，当用户和页面交互，页面的渲染层合并线程将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致JavaScript、布局和绘制过程发生。 但是如果被触摸的元素绑定了输入事件处理函数，比如touchstart/touchmove/touchend，那么渲染层合并线程必须等待这些被绑定的处理函数执行完毕才能执行，也就是用户的滚动页面操作被阻塞了，表现出的行为就是滚动出现延迟或者卡顿。 简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够快速的执行完毕，以便腾出时间来让渲染层合并线程完成他的工作。 2. 避免在输入事件处理函数中修改样式属性 输入事件处理函数，比如scroll/touch事件的处理，都会在requestAnimationFrame之前被调用执行。 因此，如果你在上述输入事件的处理函数中做了修改样式属性的操作，那么这些操作就会被浏览器暂存起来，然后在调用requestAnimationFrame的时候，如果你在一开始就做了读取样式属性的操作，那么将会触发浏览器的强制同步布局操作。 3. 对滚动事件处理函数去抖动 通过requestAnimationFrame可以对样式修改操作去抖动，同时也可以使你的事件处理函数变得更轻 ```javascript function onScroll(evt) { // Store the scroll value for laterz. lastScrollY = window.scrollY; // Prevent multiple rAF callbacks. if (scheduledAnimationFrame) { return; } scheduledAnimationFrame = true; requestAnimationFrame(readAndUpdatePage); } window.addEventListener(&apos;scroll&apos;, onScroll); ```javascript","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"设计模式之发布订阅模式","slug":"设计模式之发布订阅模式","date":"2018-10-28T13:44:56.000Z","updated":"2019-07-14T13:58:22.044Z","comments":true,"path":"2018/10/28/设计模式之发布订阅模式/","link":"","permalink":"http://yoursite.com/2018/10/28/设计模式之发布订阅模式/","excerpt":"","text":"###1. 基本概念发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。 2. 现实例子买房者订阅售楼处房产消息，当有新的楼盘推出时，售楼处会一一向已订阅的买房者发送消息，无需买房者每天来咨询是否有新的楼盘，售楼处也无需关注买房者的任何情况，只是负责发送消息。 3. 特点从上面的例子中可以看出使用发布—订阅模式有着显而易见的优点。 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。这一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax 请求的 error、success等事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把联系方式留在售楼处，售楼处不关心购房者的任何情况只要售楼处记得发短信这件事情。这说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 4. js事件机制中的发布订阅模式1234document.body.addEventListener( 'click', function()&#123;//订阅消息 alert(2); &#125;, false ); document.body.click(); // 模拟用户点击，发布消息 在这里需要监控用户点击 document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时，body 节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。 5. 自定义事件-实现发布订阅模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var Event = &#123; //封装发布订阅的功能 clientList:[], // 订阅者列表 listen:function(key, fn)&#123; // 添加订阅者 if(!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn) // 订阅的消息添加进缓存列表 &#125;, remove:function(key, fn) &#123;//取消订阅者 var fns = this.clientList[key]; if(!fns) &#123; return false; &#125; if(!fn) &#123; fns &amp;&amp; fns.length = 0; &#125; else &#123; for ( var l = fns.length - 1; l &gt;=0; l-- )&#123; // 反向遍历订阅的回调函数列表 var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); // 删除订阅者的回调函数 &#125; &#125; &#125; &#125; trigger:function()&#123; var key = Array.prototype.shift.call(argumets); var fns = this.clientList[key]; if(!fns || fns.length === 0) &#123;//没有绑定对应的消息 return false; &#125; for(var i = 0; i &lt; fns.length; i++) &#123; var fn = fns[i]; fn.apply(this, arguments); &#125; &#125; &#125;; var installEvent = function(obj) &#123; //给所有的对象都动态安装发布—订阅功能 for(var i in event) &#123; obj[i] = event[i]; &#125; &#125; //测试 installEvent( salesOffices ); salesOffices.listen( 'squareMeter88', fn1 = function( price )&#123; // 小明订阅88消息 console.log( '小明received ' + price ); &#125;); salesOffices.listen( 'squareMeter88', fn2 = function( price )&#123; // 小红订阅88消息 console.log( '小红received ' + price ); &#125;); salesOffices.listen( 'squareMeter100', function( price )&#123; // 小红订阅100消息 console.log( '小红received ' + price ); &#125;); salesOffices.trigger( 'squareMeter88', 20000 ); // 输出：小明received 20000, 小红received 20000 salesOffices.trigger( 'squareMeter100', 30000 ); // 输出：小红received 30000 salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅 salesOffices.trigger( 'squareMeter88', 20000 ); // 输出：小红received 20000 6. 全局的发布－订阅对象在5中每个发布者对象都添加了 listen 和 trigger 方法，以及一个缓存列表 clientList，这其实是一种资源浪费。当一个订阅者想要订阅另外一个对象消息时，也必须要创建一个新的对象。类似现实中的房产中介，发布—订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来。123456789101112131415161718192021222324252627282930313233343536373839404142434445var Event = (function()&#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function( key, fn )&#123; if (!clientList[ key ])&#123; clientList[ key ] = []; &#125; clientList[ key ].push( fn ); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call( arguments ), fns = clientList[ key ]; if ( !fns || fns.length === 0 )&#123; return false; &#125; for( var i = 0, fn; fn = fns[ i++ ]; )&#123; fn.apply( this, arguments ); &#125; &#125;; remove = function( key, fn )&#123; var fns = clientList[ key ]; if ( !fns )&#123; return false; &#125; if ( !fn )&#123; fns &amp;&amp; ( fns.length = 0 ); &#125; else &#123; for ( var l = fns.length - 1; l &gt;=0; l-- )&#123; var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125; &#125;)(); Event.listen( 'squareMeter88', function( price )&#123; // 小红订阅消息 console.log( '价格= ' + price ); // 输出：'价格=2000000' &#125;); Event.trigger( 'squareMeter88', 2000000 ); // 售楼处发布消息 7. 总结发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是 MVC 还是 MVVM，都少不了发布—订阅模式的参与，而且 JavaScript本身也是一门基于事件驱动的语言。当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-21T02:44:29.433Z","updated":"2018-10-21T02:44:29.433Z","comments":true,"path":"2018/10/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}