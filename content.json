{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Daisy","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"浏览器关键渲染路径与阻塞渲染以及渲染优化","slug":"浏览器关键渲染路径与阻塞渲染以及渲染优化","date":"2018-11-01T14:12:13.000Z","updated":"2019-07-14T14:57:01.778Z","comments":true,"path":"2018/11/01/浏览器关键渲染路径与阻塞渲染以及渲染优化/","link":"","permalink":"http://yoursite.com/2018/11/01/浏览器关键渲染路径与阻塞渲染以及渲染优化/","excerpt":"","text":"1. 前言 在浏览器拿到HTML, CSS JS 等外部资源到渲染出页面的过程，有一个重要的概念，例如为了保障首屏内容的最快速显示，通常会提到一个渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。了解原理可以让我们更好的优化关键渲染路径，从而获得更好的用户体验。 2. 阻塞资源 现代浏览器总是并行加载资源，例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。 同时由于： 1. CSS 被视为渲染阻塞资源(包括JS)，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕，才会进行下一阶段。 2. JavaScript 被认为是解释器阻塞资源，HTML解析会被JS阻塞，它不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。 存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外： 1. 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。 2. JavaScript 可以查询和修改 DOM 与 CSSOM。 3. CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则： 1. CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。 2. JavaScript 应尽量少影响 DOM 的构建。 3. CSS加载 &lt;style&gt; p { color: red; }&lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。 渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。 最容易想到的当然是精简 CSS 并尽快提供它。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。&lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt; &lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&gt;第一个资源会加载并阻塞。第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。第三个资源提供了媒体查询，会在符合条件时阻塞渲染。 关于CSS加载的阻塞情况： css加载不会阻塞DOM树的解析 css加载会阻塞DOM树的渲染 css加载会阻塞后面js语句的执行 没有js的理想情况下，html与css会并行解析，分别生成DOM与CSSOM，然后合并成Render Tree，进入Rendering Pipeline；但如果有js，css加载会阻塞后面js语句的执行，而（同步）js脚本执行会阻塞其后的DOM解析（所以通常会把css放在头部，js放在body尾） 4. JS加载 如果没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的HTML元素之前，也就是说不等待后续载入的HTML元素，读到就加载并执行 解析过程中无论遇到的JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒JavaScript解析器，就会进行暂停 (blocked )浏览器解析HTML，并等到 CSSOM 构建完毕，才去执行js脚本。因为脚本中可能会操作DOM元素，而如果在加载执行脚本的时候DOM元素并没有被解析，脚本就会因为DOM元素没有生成取不到响应元素，所以实际工程中，我们常常将资源放到文档底部。 改变脚本加载次序defer与asyncdefer 与 async 可以改变之前的那些阻塞情形，这两个属性都会使 script 异步加载，然而执行的时机是不一样的。注意 async 与 defer 属性对于 inline-script 都是无效的1.defer &lt;script src=&quot;app1.js&quot; defer&gt;&lt;/script&gt; &lt;script src=&quot;app2.js&quot; defer&gt;&lt;/script&gt; &lt;script src=&quot;app3.js&quot; defer&gt;&lt;/script&gt; defer 属性表示延迟执行引入 JavaScript，即 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，再触发DOMContentLoaded(初始的 HTML 文档被完全加载和解析完成之后触发，无需等待样式表图像和子框架的完成加载) 事件。 defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。 2.asyncasync 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发(HTML解析完成事件)之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。从上一段也能推出，多个 async-script 的执行顺序是不确定的，谁先加载完谁执行。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true。 5. 优化渲染性能 1.动画实现使用requestAnimationFrame 2.长耗时的JS代码放到Web Worker 中执行 JS代码运行在浏览器的主线程上，与此同时，浏览器的主线程还负责样式计算、布局、绘制的工作，如果JavaScript代码运行时间过长，就会阻塞其他渲染工作，很可能会导致丢帧。 每帧的渲染应该在16ms内完成，但在动画过程中，由于已经被占用了不少时间，所以JavaScript代码运行耗时应该控制在3-4毫秒。 如果真的有特别耗时且不操作DOM元素的纯计算工作，可以考虑放到Web Workers中执行。 3.拆分操作DOM元素的任务，分别在多个frame完成 由于Web Workers不能操作DOM元素的限制，所以只能做一些纯计算的工作，对于很多需要操作DOM元素的逻辑，可以考虑分步处理，把任务分为若干个小任务，每个任务都放到requestAnimationFrame中回调执行 4.降低样式计算的范围和复杂度 添加或移除一个DOM元素、修改元素属性和样式类、应用动画效果等操作，都会引起DOM结构的改变，从而导致浏览器要repaint或者reflow。那么这里可以采取一些措施。 1. 降低样式选择器的复杂度 尽量保持class的简短，或者使用Web Components框架。 `.box:nth-last-child(-n+1) .title {} // 改善后 .final-box-title {}` 2. 减少需要执行样式计算的元素个数 由于浏览器的优化，现代浏览器的样式计算直接对目标元素执行，而不是对整个页面执行，所以我们应该尽可能减少需要执行样式计算的元素的个数。 5.避免大规模、复杂的布局 布局就是计算DOM元素的大小和位置的过程，如果你的页面中包含很多元素，那么计算这些元素的位置将耗费很长时间。布局的主要消耗在于:1. 需要布局的DOM元素的数量; 2.布局过程的复杂程度。 1. 尽可能避免触发布局 当你修改了元素的属性之后，浏览器将会检查为了使这个修改生效是否需要重新计算布局以及更新渲染树，对于DOM元素的几何属性修改，比如width/height/left/top等，都需要重新计算布局。 对于不能避免的布局，可以使用Chrome DevTools工具的Timeline查看布局的耗时，以及受影响的DOM元素数量。 2. 使用flexbox替代老的布局模型 老的布局模型以相对/绝对/浮动的方式将元素定位到屏幕上，而Floxbox布局模型用流式布局的方式将元素定位到屏幕上。通过一个小实验可以看出 3. 避免强制同步布局事件的发生 根据渲染流程，JS脚本是在layout之前执行，但是我们可以强制浏览器在执行JS脚本之前先执行布局过程，这就是所谓的强制同步布局。 12345678910111213141516requestAnimationFrame(logBoxHeight);// 先写后读，触发强制布局function logBoxHeight() &#123; // 更新box样式 box.classList.add('super-big'); // 为了返回box的offersetHeight值 // 浏览器必须先应用属性修改，接着执行布局过程 console.log(box.offsetHeight);&#125;// 先读后写，避免强制布局function logBoxHeight() &#123; // 获取box.offsetHeight console.log(box.offsetHeight); // 更新box样式 box.classList.add('super-big');&#125; 在JS脚本运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧的值。因此，如果你在当前帧获取属性之前又对元素节点有改动，那就会导致浏览器必须先应用属性修改，结果执行布局过程，最后再执行JS逻辑。 4. 避免连续的强制同步布局发生 如果连续快速的多次触发强制同步布局，那么结果更糟糕。 比如下面的例子，获取box的属性，设置到paragraphs上，由于每次设置paragraphs都会触发样式计算和布局过程，而下一次获取box的属性必须等到上一步设置结束之后才能触发。 1234567891011121314function resizeWidth() &#123; // 会让浏览器陷入'读写读写'循环 for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px'; &#125;&#125;// 改善后方案var width = box.offsetWidth;function resizeWidth() &#123; for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px'; &#125;&#125; 5. 简化绘制的复杂度、减少绘制区域 Paint就是填充像素的过程，通常这个过程是整个渲染流程中耗时最长的一环，因此也是最需要避免发生的一环。 如果Layout被触发，那么接下来元素的Paint一定会被触发。当然纯粹改变元素的非几何属性，也可能会触发Paint，比如背景、文字颜色、阴影效果等。 1. 提升移动或渐变元素的绘制层 绘制并非总是在内存中的单层画面里完成的，实际上，浏览器在必要时会将一帧画面绘制成多层画面，然后将这若干层画面合并成一张图片显示到屏幕上。 这种绘制方式的好处是，使用transform来实现移动效果的元素将会被正常绘制，同时不会触发其他元素的绘制。 2. 减少绘制区域，简化绘制的复杂度 浏览器会把相邻区域的渲染任务合并在一起进行，所以需要对动画效果进行精密设计，以保证各自的绘制区域不会有太多重叠。 另外可以实现同样效果的不同方式，应该采用性能更好的那种。 3. 通过Chrome DevTools来分析绘制复杂度和时间消耗，尽可能降低这些指标 打开DevTools，在弹出的面板中，选中More Tools &gt; Rendering选项卡下的Paint flashing，这样每当页面发生绘制的时候，屏幕就会闪现绿色的方框。通过该工具可以检查Paint发生的区域和时机是不是可以被优化。 通过Chrome DevTools中的Timeline &gt; Paint选项可以查看更细节的Paint信息 6.优先使用渲染层合并属性、控制层数量 1. 使用transform/opacity实现动画效果 使用transform/opacity实现动画效果，会跳过渲染流程的布局和绘制环节，只做渲染层的合并。 Type Func Position transform: translate(-px,-px) Scale transform: scale(-) Rotation transform: rotate(-deg) Skew transform: skew(X/Y)(-deg) Matrix transform: matrix(3d)(..) Opacity opacity: 0-1 使用transform/opacity的元素必须独占一个渲染层，所以必须提升该元素到单独的渲染层。 2. 提升动画效果中的元素 应用动画效果的元素应该被提升到其自有的渲染层，但不要滥用。 在页面中创建一个新的渲染层最好的方式就是使用CSS属性will-change，对于目前还不支持will-change属性、但支持创建渲染层的浏览器，可以通过3D transform属性来强制浏览器创建一个新的渲染层。需要注意的是，不要创建过多的渲染层，这意味着新的内存分配和更复杂的层管理。 注意，IE11，Edge17都不支持这一属性。 `.moving-element { will-change: transform; transform: translateZ(0); }` 3. 管理渲染层、避免过多数量的层 尽管提升渲染层看起来很诱人，但不能滥用，因为更多的渲染层意味着更多的额外的内存和管理资源，所以当且仅当需要的时候才为元素创建渲染层。 `* { will-change: transform; transform: translateZ(0); }` 4. 使用Chrome DevTools来了解页面的渲染层情况 开启Timeline &gt; Paint选项，然后录制一段时间的操作，选择单独的帧，看到每个帧的渲染细节，在ESC弹出框有个Layers选项，可以看到渲染层的细节，有多少渲染层，为何被创建？ 8. 对用户输入事件的处理函数去抖动（移动设备） 用户输入事件处理函数会在运行时阻塞帧的渲染，并且会导致额外的布局发生。 1. 避免使用运行时间过长的输入事件处理函数 理想情况下，当用户和页面交互，页面的渲染层合并线程将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致JavaScript、布局和绘制过程发生。 但是如果被触摸的元素绑定了输入事件处理函数，比如touchstart/touchmove/touchend，那么渲染层合并线程必须等待这些被绑定的处理函数执行完毕才能执行，也就是用户的滚动页面操作被阻塞了，表现出的行为就是滚动出现延迟或者卡顿。 简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够快速的执行完毕，以便腾出时间来让渲染层合并线程完成他的工作。 2. 避免在输入事件处理函数中修改样式属性 输入事件处理函数，比如scroll/touch事件的处理，都会在requestAnimationFrame之前被调用执行。因此，如果你在上述输入事件的处理函数中做了修改样式属性的操作，那么这些操作就会被浏览器暂存起来，然后在调用requestAnimationFrame的时候，如果你在一开始就做了读取样式属性的操作，那么将会触发浏览器的强制同步布局操作。 3. 对滚动事件处理函数去抖动 通过requestAnimationFrame可以对样式修改操作去抖动，同时也可以使你的事件处理函数变得更轻 12345678910111213function onScroll(evt) &#123; // Store the scroll value for laterz. lastScrollY = window.scrollY; // Prevent multiple rAF callbacks. if (scheduledAnimationFrame) &#123; return; &#125; scheduledAnimationFrame = true; requestAnimationFrame(readAndUpdatePage);&#125;window.addEventListener('scroll', onScroll);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"typeScript类","slug":"typescript类","date":"2018-10-30T14:20:56.000Z","updated":"2019-07-18T20:16:22.324Z","comments":true,"path":"2018/10/30/typescript类/","link":"","permalink":"http://yoursite.com/2018/10/30/typescript类/","excerpt":"","text":"1.基本使用1234567891011class Greeter &#123; greeting: string;//成员属性 constructor(message: string) &#123;//构造函数 this.greeting = message; &#125; greet() &#123;//成员方法 return \"Hello, \" + this.greeting; &#125;&#125;let greeter = new Greeter(\"world\"); 2.继承使用extends关键字实现继承,子类可以对父类的方法进行重写。若子类包含了一个构造函数，它 必须调用 super()，它会执行父类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 123456789101112131415161718192021222324252627282930class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\"); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(\"Sammy the Python\");//Slithering...let tom: Animal = new Horse(\"Tommy the Palomino\");//Galloping...sam.move(); // Sammy the Python moved 5m.tom.move(34); //Tommy the Palomino moved 34m. 3.成员修饰符3.1 public在TypeScript里，成员都默认为 public。都是可自由访问的。 3.2 private当成员被标记成 private时，它就不能在声明它的类的外部访问。比如： 123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(\"Cat\").name; // 错误: 'name' 是私有的. 3.3 protectedprotected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如： 123456789101112131415161718192021class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如， 123456789101112131415161718192021class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的. 3.4 readonly你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化 123456789class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的. 3.5参数属性参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于readonly, public和 protected来说也是一样。 12345class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; &#125;&#125; 4.setter and getter123456789101112131415161718192021222324let passcode = \"secret passcode\";class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123;//通过setter 可以控制变量的访问权限 if (passcode &amp;&amp; passcode == \"secret passcode\") &#123; this._fullName = newName; &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; alert(employee.fullName);&#125; ps:带有 get不带有 set的存取器自动被推断为 readonly。 5.static 静态属性静态属性由static关键字来定义，存在于类上，而不是类的实例对象。当访问静态属性需要以类名为前缀，而实例属性以this为前缀。 123456789101112131415class Grid &#123; static origin = &#123;x: 0, y: 0&#125;; calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor (public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));console.log(grid2.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;)); 6.抽象类 抽象类做为其它派生类的基类使用。 不可被直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。 123456789101112131415161718192021222324252627282930313233abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log('Department name: ' + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125; generateReports(): void &#123; console.log('Generating accounting reports...'); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在","categories":[],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://yoursite.com/tags/typeScript/"}]},{"title":"typeScript基础数据类型","slug":"typeScript基础数据类型","date":"2018-10-30T13:44:56.000Z","updated":"2019-07-18T20:21:58.050Z","comments":true,"path":"2018/10/30/typeScript基础数据类型/","link":"","permalink":"http://yoursite.com/2018/10/30/typeScript基础数据类型/","excerpt":"","text":"1.任意类型 any声明为 any 的变量可以赋予任意类型的值。123let x: any = 1; // 数字类型x = 'hello wordl'; // 字符串类型x = false; // 布尔类型 2.数字类型 number双精度 64 位浮点值。它可以用来表示整数和小数。1234let binaryLiteral: number = 0b1010; // 二进制let octalLiteral: number = 0o744; // 八进制let decLiteral: number = 6; // 十进制let hexLiteral: number = 0xf00d; // 十六进制 3.字符串类型 string一个字符系列，使用单引号&apos;或双引号&quot;来表示字符串类型。反引号`来定义多行文本和内嵌表达式。 123let nickname: string = \"Daisy\";let age: number = 17;let words: string = `hello,my name is $&#123;nickname&#125;, I am $&#123;age&#125; years old`; 4.布尔类型 boolean 表示逻辑值：true 和 false。 let flag: boolean = true; 5.数组类型 array1234// 在元素类型后面加上[]let arr: number[] = [1, 2]; //number类型数组// 或者使用数组泛型let arr: Array&lt;number&gt; = [1, 2]; 6.元组类型元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。 1234let x: [string, number];x = ['xxx', 1]; // 运行正常x = [1, 'xxx']; // 报错console.log(x[0]); // 输出 xxx 7.枚举类型enum枚举类型用于定义数值集合。 123enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Blue;console.log(c); // 输出 2 8.void用于标识方法返回值的类型，表示该方法没有返回值。 123functin hello(nickname:string) : void&#123; console.log(`hello $&#123;nickname&#125;`)&#125; 8.nullnull是一个只有一个值的特殊类型。表示一个空对象引用。用 typeof 检测 null 返回是 object。 9.undefined在 JavaScript 中, undefined 是一个没有设置值的变量。typeof 一个没有值的变量会返回 undefined。null 和 undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（--strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下： 1234let x: number;x = 1; // 运行正确x = undefined; // 运行错误x = null; // 运行错误 上面的例子中变量 x 只能是数字类型。如果一个类型可能出行 null 或 undefined， 可以用 | 来支持多种类型，示例代码如下： 1234let x: number | null | undefined;x = 1; // 运行正确x = undefined; // 运行正确x = null; // 运行正确 10.never 类型never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环），示例代码如下： 123456789101112131415161718192021let x: never;let y: number;// 运行错误，数字类型不能转为 never 类型x = 123;// 运行正确，never 类型可以赋值给 never类型x = (()=&gt;&#123; throw new Error('exception')&#125;)();// 运行正确，never 类型可以赋值给 数字类型y = (()=&gt;&#123; throw new Error('exception')&#125;)();// 返回值为 never 的函数可以是抛出异常的情况function error(message: string): never &#123; throw new Error(message);&#125;// 返回值为 never 的函数可以是无法被执行到的终止点的情况function loop(): never &#123; while (true) &#123;&#125;&#125;","categories":[],"tags":[{"name":"typeScript","slug":"typeScript","permalink":"http://yoursite.com/tags/typeScript/"}]},{"title":"设计模式之发布订阅模式","slug":"设计模式之发布订阅模式","date":"2018-10-28T13:44:56.000Z","updated":"2019-07-18T20:21:07.987Z","comments":true,"path":"2018/10/28/设计模式之发布订阅模式/","link":"","permalink":"http://yoursite.com/2018/10/28/设计模式之发布订阅模式/","excerpt":"","text":"1. 基本概念发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。 2. 现实例子买房者订阅售楼处房产消息，当有新的楼盘推出时，售楼处会一一向已订阅的买房者发送消息，无需买房者每天来咨询是否有新的楼盘，售楼处也无需关注买房者的任何情况，只是负责发送消息。 3. 特点从上面的例子中可以看出使用发布—订阅模式有着显而易见的优点。 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。这一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax 请求的 error、success等事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把联系方式留在售楼处，售楼处不关心购房者的任何情况只要售楼处记得发短信这件事情。这说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 4. js事件机制中的发布订阅模式1234document.body.addEventListener( 'click', function()&#123;//订阅消息 alert(2); &#125;, false ); document.body.click(); // 模拟用户点击，发布消息 在这里需要监控用户点击 document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时，body 节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。 5. 自定义事件-实现发布订阅模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var Event = &#123; //封装发布订阅的功能 clientList:[], // 订阅者列表 listen:function(key, fn)&#123; // 添加订阅者 if(!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn) // 订阅的消息添加进缓存列表 &#125;, remove:function(key, fn) &#123;//取消订阅者 var fns = this.clientList[key]; if(!fns) &#123; return false; &#125; if(!fn) &#123; fns &amp;&amp; fns.length = 0; &#125; else &#123; for ( var l = fns.length - 1; l &gt;=0; l-- )&#123; // 反向遍历订阅的回调函数列表 var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); // 删除订阅者的回调函数 &#125; &#125; &#125; &#125; trigger:function()&#123; var key = Array.prototype.shift.call(argumets); var fns = this.clientList[key]; if(!fns || fns.length === 0) &#123;//没有绑定对应的消息 return false; &#125; for(var i = 0; i &lt; fns.length; i++) &#123; var fn = fns[i]; fn.apply(this, arguments); &#125; &#125; &#125;; var installEvent = function(obj) &#123; //给所有的对象都动态安装发布—订阅功能 for(var i in event) &#123; obj[i] = event[i]; &#125; &#125; //测试 installEvent( salesOffices ); salesOffices.listen( 'squareMeter88', fn1 = function( price )&#123; // 小明订阅88消息 console.log( '小明received ' + price ); &#125;); salesOffices.listen( 'squareMeter88', fn2 = function( price )&#123; // 小红订阅88消息 console.log( '小红received ' + price ); &#125;); salesOffices.listen( 'squareMeter100', function( price )&#123; // 小红订阅100消息 console.log( '小红received ' + price ); &#125;); salesOffices.trigger( 'squareMeter88', 20000 ); // 输出：小明received 20000, 小红received 20000 salesOffices.trigger( 'squareMeter100', 30000 ); // 输出：小红received 30000 salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅 salesOffices.trigger( 'squareMeter88', 20000 ); // 输出：小红received 20000 6. 全局的发布－订阅对象在5中每个发布者对象都添加了 listen 和 trigger 方法，以及一个缓存列表 clientList，这其实是一种资源浪费。当一个订阅者想要订阅另外一个对象消息时，也必须要创建一个新的对象。类似现实中的房产中介，发布—订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来。123456789101112131415161718192021222324252627282930313233343536373839404142434445var Event = (function()&#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function( key, fn )&#123; if (!clientList[ key ])&#123; clientList[ key ] = []; &#125; clientList[ key ].push( fn ); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call( arguments ), fns = clientList[ key ]; if ( !fns || fns.length === 0 )&#123; return false; &#125; for( var i = 0, fn; fn = fns[ i++ ]; )&#123; fn.apply( this, arguments ); &#125; &#125;; remove = function( key, fn )&#123; var fns = clientList[ key ]; if ( !fns )&#123; return false; &#125; if ( !fn )&#123; fns &amp;&amp; ( fns.length = 0 ); &#125; else &#123; for ( var l = fns.length - 1; l &gt;=0; l-- )&#123; var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125; &#125;)(); Event.listen( 'squareMeter88', function( price )&#123; // 小红订阅消息 console.log( '价格= ' + price ); // 输出：'价格=2000000' &#125;); Event.trigger( 'squareMeter88', 2000000 ); // 售楼处发布消息 7. 总结发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是 MVC 还是 MVVM，都少不了发布—订阅模式的参与，而且 JavaScript本身也是一门基于事件驱动的语言。当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-21T02:44:29.433Z","updated":"2018-10-21T02:44:29.433Z","comments":true,"path":"2018/10/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}