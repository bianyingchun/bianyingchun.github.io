{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"设计模式之发布订阅模式","slug":"设计模式之发布订阅模式","date":"2018-10-28T13:44:56.000Z","updated":"2018-10-28T15:00:08.811Z","comments":true,"path":"2018/10/28/设计模式之发布订阅模式/","link":"","permalink":"http://yoursite.com/2018/10/28/设计模式之发布订阅模式/","excerpt":"","text":"1. 基本概念发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。 2. 现实例子买房者订阅售楼处房产消息，当有新的楼盘推出时，售楼处会一一向已订阅的买房者发送消息，无需买房者每天来咨询是否有新的楼盘，售楼处也无需关注买房者的任何情况，只是负责发送消息。 3. 特点从上面的例子中可以看出使用发布—订阅模式有着显而易见的优点。 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。这一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax 请求的 error、succ 等事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把联系方式留在售楼处，售楼处不关心购房者的任何情况只要售楼处记得发短信这件事情。这说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 4. js事件机制中的发布订阅模式1234document.body.addEventListener( 'click', function()&#123;//订阅消息 alert(2); &#125;, false ); document.body.click(); // 模拟用户点击，发布消息 在这里需要监控用户点击 document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时，body 节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。 5. 自定义事件-实现发布订阅模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var Event = &#123; //封装发布订阅的功能 clientList:[], // 订阅者列表 listen:function(key, fn)&#123; // 添加订阅者 if(!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn) // 订阅的消息添加进缓存列表 &#125;, remove:function(key, fn) &#123;//取消订阅者 var fns = this.clientList[key]; if(!fns) &#123; return false; &#125; if(!fn) &#123; fns &amp;&amp; fns.length = 0; &#125; else &#123; for ( var l = fns.length - 1; l &gt;=0; l-- )&#123; // 反向遍历订阅的回调函数列表 var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); // 删除订阅者的回调函数 &#125; &#125; &#125; &#125; trigger:function()&#123; var key = Array.prototype.shift.call(argumets); var fns = this.clientList[key]; if(!fns || fns.length === 0) &#123;//没有绑定对应的消息 return false; &#125; for(var i = 0; i &lt; fns.length; i++) &#123; var fn = fns[i]; fn.apply(this, arguments); &#125; &#125; &#125;; var installEvent = function(obj) &#123; //给所有的对象都动态安装发布—订阅功能 for(var i in event) &#123; obj[i] = event[i]; &#125; &#125; //测试 installEvent( salesOffices ); salesOffices.listen( 'squareMeter88', fn1 = function( price )&#123; // 小明订阅88消息 console.log( '小明received ' + price ); &#125;); salesOffices.listen( 'squareMeter88', fn2 = function( price )&#123; // 小红订阅88消息 console.log( '小红received ' + price ); &#125;); salesOffices.listen( 'squareMeter100', function( price )&#123; // 小红订阅100消息 console.log( '小红received ' + price ); &#125;); salesOffices.trigger( 'squareMeter88', 20000 ); // 输出：小明received 20000, 小红received 20000 salesOffices.trigger( 'squareMeter100', 30000 ); // 输出：小红received 30000 salesOffices.remove( 'squareMeter88', fn1 ); // 删除小明的订阅 salesOffices.trigger( 'squareMeter88', 20000 ); // 输出：小红received 20000 6. 全局的发布－订阅对象在5中每个发布者对象都添加了 listen 和 trigger 方法，以及一个缓存列表 clientList，这其实是一种资源浪费。当一个订阅者想要订阅另外一个对象消息时，也必须要创建一个新的对象。类似现实中的房产中介，发布—订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来。123456789101112131415161718192021222324252627282930313233343536373839404142434445var Event = (function()&#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function( key, fn )&#123; if (!clientList[ key ])&#123; clientList[ key ] = []; &#125; clientList[ key ].push( fn ); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call( arguments ), fns = clientList[ key ]; if ( !fns || fns.length === 0 )&#123; return false; &#125; for( var i = 0, fn; fn = fns[ i++ ]; )&#123; fn.apply( this, arguments ); &#125; &#125;; remove = function( key, fn )&#123; var fns = clientList[ key ]; if ( !fns )&#123; return false; &#125; if ( !fn )&#123; fns &amp;&amp; ( fns.length = 0 ); &#125; else &#123; for ( var l = fns.length - 1; l &gt;=0; l-- )&#123; var _fn = fns[ l ]; if ( _fn === fn )&#123; fns.splice( l, 1 ); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125; &#125;)(); Event.listen( 'squareMeter88', function( price )&#123; // 小红订阅消息 console.log( '价格= ' + price ); // 输出：'价格=2000000' &#125;); Event.trigger( 'squareMeter88', 2000000 ); // 售楼处发布消息 7. 总结发布—订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是 MVC 还是 MVVM，都少不了发布—订阅模式的参与，而且 JavaScript本身也是一门基于事件驱动的语言。当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是件轻松的事情。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-21T02:44:29.433Z","updated":"2018-10-21T02:44:29.433Z","comments":true,"path":"2018/10/21/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}